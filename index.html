<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pitch Toy - Developer Debug Interface</title>
    <link data-trunk rel="copy-file" href="web/debug-interface.css">
    <link data-trunk rel="copy-file" href="web/microphone-permission.css">
    <link rel="stylesheet" href="debug-interface.css">
    <link rel="stylesheet" href="microphone-permission.css">
    <style>
        /* Essential base styles to ensure external CSS works */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: #f8f9fa;
            color: #333;
        }
    </style>

    <script>
        // Real-time microphone analysis functions for Web Audio API
        window.setupMicrophoneAnalysis = function(stream) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                analyser.smoothingTimeConstant = 0.3;
                
                const source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);
                
                console.log('Real-time microphone analysis set up successfully');
                return analyser;
            } catch (error) {
                console.error('Failed to set up microphone analysis:', error);
                return null;
            }
        };

        window.getMicrophoneLevel = function(analyser) {
            if (!analyser) return 0.0;
            
            const bufferLength = analyser.fftSize;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(dataArray);
            
            // Calculate RMS level
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                const sample = (dataArray[i] - 128) / 128;
                sum += sample * sample;
            }
            
            const rms = Math.sqrt(sum / dataArray.length);
            return Math.min(rms * 5.0, 1.0); // Amplify sensitivity and cap at 1.0
        };

        window.cleanupMicrophoneAnalysis = function(analyser) {
            if (analyser && analyser.context) {
                analyser.context.close();
            }
        };

        // Get audio output device name from AudioContext
        window.getAudioOutputDeviceName = async function() {
            try {
                // Try to get default output device info
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioOutputs = devices.filter(device => device.kind === 'audiooutput');
                
                if (audioOutputs.length > 0) {
                    // Find the default output device (usually the first one)
                    const defaultOutput = audioOutputs.find(device => device.deviceId === 'default') || audioOutputs[0];
                    if (defaultOutput && defaultOutput.label && defaultOutput.label.trim() !== '') {
                        console.log('Audio output device name:', defaultOutput.label);
                        return defaultOutput.label;
                    }
                }
                
                // Fallback: try to detect from AudioContext
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    // Most browsers don't expose output device info from AudioContext
                    // So we return a generic name based on platform detection
                    const userAgent = navigator.userAgent.toLowerCase();
                    if (userAgent.includes('mac')) {
                        return 'Built-in Output';
                    } else if (userAgent.includes('windows')) {
                        return 'Default Speakers';
                    } else if (userAgent.includes('linux')) {
                        return 'System Audio';
                    } else {
                        return 'Audio Output';
                    }
                } catch (error) {
                    console.warn('Could not create AudioContext for output detection:', error);
                    return 'Audio Output';
                }
                
            } catch (error) {
                console.error('Error getting audio output device name:', error);
                return null;
            }
        };

        // Get available audio input devices
        window.getAudioInputDevices = async function() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(device => device.kind === 'audioinput');
                
                return audioInputs.map(device => ({
                    deviceId: device.deviceId,
                    label: device.label || `Microphone ${device.deviceId.slice(0, 8)}`,
                    groupId: device.groupId
                }));
            } catch (error) {
                console.error('Error getting audio input devices:', error);
                return [];
            }
        };

        // Switch to a specific input device
        window.switchToInputDevice = async function(deviceId) {
            try {
                console.log('Switching to input device:', deviceId);
                
                const constraints = {
                    audio: {
                        deviceId: deviceId ? { exact: deviceId } : undefined,
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                };
                
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                console.log('Successfully switched to device:', deviceId);
                return stream;
            } catch (error) {
                console.error('Error switching input device:', error);
                throw error;
            }
        };

        // Get actual microphone device name from MediaStream
        window.getMicrophoneDeviceName = async function(stream) {
            try {
                if (!stream || !stream.getAudioTracks) {
                    return "Unknown Device";
                }
                
                const audioTracks = stream.getAudioTracks();
                if (audioTracks.length === 0) {
                    return "No Audio Device";
                }
                
                const track = audioTracks[0];
                
                // Try to get device label from track
                if (track.label && track.label.trim() !== '') {
                    console.log('Device name from track label:', track.label);
                    return track.label;
                }
                
                // Try to get device info from constraints/settings
                if (track.getSettings) {
                    const settings = track.getSettings();
                    if (settings.deviceId) {
                        // Try to get device name from enumerateDevices
                        try {
                            const devices = await navigator.mediaDevices.enumerateDevices();
                            const audioDevice = devices.find(device => 
                                device.kind === 'audioinput' && device.deviceId === settings.deviceId
                            );
                            if (audioDevice && audioDevice.label && audioDevice.label.trim() !== '') {
                                console.log('Device name from enumerateDevices:', audioDevice.label);
                                return audioDevice.label;
                            }
                        } catch (error) {
                            console.warn('Could not enumerate devices:', error);
                        }
                    }
                }
                
                // Fallback to default name
                console.log('Using fallback device name');
                return "Default Audio Input";
                
            } catch (error) {
                console.error('Error getting microphone device name:', error);
                return "Unknown Device";
            }
        };
    </script>
</head>
<body>

    <link data-trunk rel="rust" data-bin="pitch-toy" />
</body>
</html> 