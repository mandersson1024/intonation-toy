# Story 5.30: Developer UI Event Integration

## Status: Draft

## Story

As a **developer**, I want **developer UI components integrated with the module event system** so that I can **monitor application state changes and trigger debug actions through the debug overlay**.

## Acceptance Criteria (ACs)

- [ ] Developer UI components can subscribe to module events for monitoring
- [ ] Debug components can publish debug/control events to the application event bus
- [ ] Event subscription cleanup on debug component unmount
- [ ] Type-safe event handling in developer UI components
- [ ] Event-driven state updates for debug monitoring displays
- [ ] Performance optimized event subscription management for debug overlay
- [ ] Developer UI component lifecycle integration with event system

## Tasks / Subtasks

- [ ] Task 1: Create developer UI event subscription system (AC: Developer UI component event subscriptions, Type-safe event handling)
  - [ ] Implement Yew hook for subscribing to module events in debug components
  - [ ] Create type-safe event handling utilities for developer UI
  - [ ] Add event subscription cleanup on component unmount
  - [ ] Implement efficient event filtering for debug components
  - [ ] Create event subscription management for debug overlay performance

- [ ] Task 2: Implement debug event publishing system (AC: Debug components can publish events, Performance optimized event management)
  - [ ] Create debug event publishing utilities for developer UI components
  - [ ] Implement debug control events (start/stop recording, device selection, etc.)
  - [ ] Add validation and error handling for debug event publishing
  - [ ] Create performance-optimized event publishing for debug overlay
  - [ ] Implement event batching for high-frequency debug events

- [ ] Task 3: Integrate debug components with event-driven state updates (AC: Event-driven state updates, Developer UI lifecycle integration)
  - [ ] Refactor AudioControlPanel to use event subscriptions for state updates
  - [ ] Update DebugPanel to subscribe to performance and error events
  - [ ] Implement event-driven metrics display updates in real-time
  - [ ] Create event-driven microphone permission status updates
  - [ ] Add event-driven test signal generator state synchronization

- [ ] Task 4: Create developer UI component lifecycle integration (AC: Developer UI component lifecycle integration, Event subscription cleanup)
  - [ ] Implement automatic event subscription cleanup in component lifecycle
  - [ ] Create debug component registration system with event bus integration
  - [ ] Add memory leak prevention for debug component event subscriptions
  - [ ] Implement conditional event subscription based on debug overlay visibility
  - [ ] Create developer UI startup/shutdown event coordination

- [ ] Task 5: Implement performance monitoring for debug event system (AC: Performance optimized event subscription management)
  - [ ] Add performance monitoring for debug event subscription/unsubscription
  - [ ] Implement event throughput monitoring for debug overlay
  - [ ] Create performance benchmarks for debug event system overhead
  - [ ] Add memory usage monitoring for debug event subscriptions
  - [ ] Implement performance alerts for debug event system bottlenecks

- [ ] Task 6: Create integration tests and documentation (AC: All ACs validation)
  - [ ] Create comprehensive integration tests for developer UI event system
  - [ ] Test event subscription cleanup and memory leak prevention
  - [ ] Validate type-safe event handling across all debug components
  - [ ] Create performance tests for debug event system overhead
  - [ ] Document developer UI event integration patterns and best practices

## Dev Technical Guidance

### Previous Story Context
[Source: docs/stories/5.29.story.md - Developer-Defined Theme System Complete]

**Key Context from Story 5.29:**
- Theme system architecture implemented with comprehensive theme management
- Graphics Foundations integration completed with wgpu rendering pipeline
- Developer UI styling isolation successfully implemented and tested
- Theme selection and persistence working with <100ms switching performance
- Debug overlay styling remains independent of theme system changes
- All debug components preserved and enhanced during theme system integration

### Source Tree Context
[Source: docs/architecture/source-tree.md#module-hierarchy]

**Implementation Target Files:**
- Developer UI Event Hooks: `src/modules/developer_ui/hooks/use_event_subscription.rs`
- Event Publishing Utilities: `src/modules/developer_ui/utils/debug_event_publisher.rs`
- Debug Component Updates: `src/modules/developer_ui/components/` (existing debug components)
- Event System Integration: `src/modules/application_core/event_bus.rs`
- Performance Monitoring: `src/modules/performance_observability/debug_performance_monitor.rs`

**Integration Points:**
- Application Core Event Bus: `src/modules/application_core/` for central event coordination
- Audio Foundations: `src/modules/audio_foundations/` for audio event subscriptions
- Developer UI Components: `src/modules/developer_ui/components/` for event-driven updates
- Performance Monitoring: `src/modules/performance_observability/` for debug performance tracking

### Architecture Context
[Source: docs/architecture/modular-restructure-architecture.md#module-interaction]

**Event System Architecture Requirements:**
- **Performance**: Event subscription/unsubscription in <1ms
- **Type Safety**: Compile-time verification of event types
- **Memory Management**: Automatic cleanup prevents memory leaks
- **Integration**: Seamless integration with existing Yew patterns

**Developer UI Event Integration Pattern:**
```rust
// Custom hook for event subscription in Yew components
#[hook]
pub fn use_event_subscription<T: Event + Clone + 'static>(
    event_bus: Rc<dyn EventBus>
) -> UseStateHandle<Option<T>> {
    let state = use_state(|| None);
    
    use_effect_with_deps(move |event_bus| {
        let event_bus = event_bus.clone();
        let state = state.clone();
        
        let subscription = event_bus.subscribe(move |event: T| {
            state.set(Some(event));
        });
        
        // Cleanup subscription on component unmount
        move || drop(subscription)
    }, event_bus);
    
    state
}

// Yew component integration with event subscriptions
#[function_component(AudioControlPanel)]
pub fn audio_control_panel(props: &AudioControlPanelProps) -> Html {
    // Subscribe to audio events
    let audio_state = use_event_subscription::<AudioEvent>(props.event_bus.clone());
    
    // Publish events on user interaction
    let event_bus = props.event_bus.clone();
    let on_start_recording = Callback::from(move |_| {
        event_bus.publish(AudioEvent::StartRecording);
    });

    html! {
        <div class="audio-control-panel">
            <button onclick={on_start_recording}>
                { if audio_state.is_recording { "Stop" } else { "Start" } }
            </button>
        </div>
    }
}
```

### Technology Stack Context
[Source: docs/architecture/tech-stack.md#yew-framework]

**Yew Framework Integration:**
- **Component Integration**: Event subscriptions via custom hooks using Yew's use_effect_with_deps
- **State Management**: Event-driven state updates using use_state with event callbacks
- **Performance**: Efficient re-rendering with selective event subscription updates
- **Memory Safety**: Automatic cleanup through Yew's component lifecycle

**Event System Performance Requirements:**
```rust
// Performance-optimized event subscription management
pub struct DebugEventSubscriptionManager {
    subscriptions: HashMap<String, Box<dyn EventSubscription>>,
    performance_monitor: Arc<DebugPerformanceMonitor>,
}

impl DebugEventSubscriptionManager {
    pub fn subscribe<T: Event + 'static>(&mut self, event_type: &str, callback: impl Fn(T) + 'static) -> Result<(), EventError> {
        let start_time = instant::Instant::now();
        
        let subscription = self.event_bus.subscribe(callback)?;
        self.subscriptions.insert(event_type.to_owned(), Box::new(subscription));
        
        let subscription_time = start_time.elapsed();
        self.performance_monitor.record_subscription_time(subscription_time);
        
        if subscription_time > Duration::from_millis(1) {
            log::warn!("Debug event subscription took {}ms (target: <1ms)", subscription_time.as_millis());
        }
        
        Ok(())
    }
}
```

### Graphics Foundations Integration
[Source: docs/stories/5.29.story.md - Theme System Complete]

**Event Integration with Graphics System:**
- Debug components must subscribe to theme change events for proper overlay coordination
- Graphics performance events should be monitored by debug performance displays
- Theme switching events need proper debug overlay state synchronization
- Graphics capability detection events for debug system compatibility validation

**Debug Event Integration Pattern:**
```rust
// Debug component integration with graphics events
#[function_component(GraphicsDebugPanel)]
pub fn graphics_debug_panel(props: &GraphicsDebugPanelProps) -> Html {
    // Subscribe to graphics performance events
    let graphics_performance = use_event_subscription::<GraphicsPerformanceEvent>(props.event_bus.clone());
    
    // Subscribe to theme change events for debug overlay coordination
    let theme_events = use_event_subscription::<ThemeChangeEvent>(props.event_bus.clone());
    
    // Display real-time graphics performance metrics
    html! {
        <div class="graphics-debug-panel">
            { if let Some(perf) = &*graphics_performance {
                format!("Render Time: {}ms", perf.render_time_ms)
            } else {
                "Waiting for graphics data..."
            }}
        </div>
    }
}
```

### Conditional Compilation Strategy
[Source: docs/architecture/modular-restructure-architecture.md#conditional-compilation]

**Debug Event System Isolation:**
- Debug event subscriptions must be conditionally compiled for debug builds only
- Event bus integration should have zero performance impact on production builds
- Debug event publishing utilities completely excluded from production
- Memory usage for debug event system must not affect production memory footprint

**Conditional Compilation Pattern:**
```rust
// Debug-only event system integration
#[cfg(debug_assertions)]
pub mod debug_event_integration {
    use super::*;
    
    pub trait DebugEventIntegration {
        fn subscribe_to_debug_events(&mut self, event_bus: Arc<dyn EventBus>) -> Result<(), EventError>;
        fn publish_debug_event(&self, event: DebugEvent) -> Result<(), EventError>;
        fn cleanup_debug_subscriptions(&mut self);
    }
    
    impl DebugEventIntegration for DeveloperUI {
        fn subscribe_to_debug_events(&mut self, event_bus: Arc<dyn EventBus>) -> Result<(), EventError> {
            // Debug event subscription implementation
            Ok(())
        }
        
        fn publish_debug_event(&self, event: DebugEvent) -> Result<(), EventError> {
            // Debug event publishing implementation
            Ok(())
        }
        
        fn cleanup_debug_subscriptions(&mut self) {
            // Cleanup debug subscriptions to prevent memory leaks
        }
    }
}

// Production builds have no debug event overhead
#[cfg(not(debug_assertions))]
pub mod debug_event_integration {
    // Empty module for production builds
}
```

### Performance Requirements
[Source: docs/architecture/coding-standards.md#performance-standards]

**Debug Event System Performance Standards:**
- **Event Subscription**: <1ms for subscription/unsubscription operations
- **Event Publishing**: <0.1ms for debug event publishing to event bus
- **Memory Usage**: Debug event subscriptions <5MB total memory footprint
- **Cleanup Efficiency**: All subscriptions cleaned up within 1ms during component unmount

### Developer Experience Design
[Source: Epic 005 - Story 030 Requirements]

**Debug Event Integration Patterns:**
- Simple, intuitive event subscription hooks for Yew components
- Type-safe event handling with compile-time verification
- Automatic cleanup preventing memory leaks in debug components
- Performance monitoring for debug event system overhead
- Clear documentation and examples for debug event integration

## Testing

Unit Tests: `#[cfg(test)]` modules next to implementation, coverage requirement: 90%

Integration Tests: `src/modules/developer_ui/integration_tests/event_integration_tests.rs`

Performance Tests: Validate event subscription <1ms requirement and debug event publishing <0.1ms

Memory Tests: Verify debug event subscriptions cleaned up properly and no memory leaks

Manual Test Steps:

1. Verify debug components receive real-time event updates from audio processing
2. Test debug event publishing triggers appropriate system responses
3. Confirm event subscription cleanup prevents memory leaks during debug overlay toggling
4. Validate type-safe event handling catches compilation errors for invalid events
5. Test performance monitoring shows debug event system overhead <1ms per operation
6. Verify conditional compilation excludes debug events from production builds
7. Confirm debug overlay remains responsive during high-frequency event scenarios
8. Test event-driven state updates maintain UI consistency during rapid state changes

## Dev Agent Record

### Agent Model Used: {{Agent Model Name/Version}}

### Debug Log References

[[LLM: (SM Agent) When Drafting Story, leave next prompt in place for dev agent to remove and update]]
[[LLM: (Dev Agent) If the debug is logged to during the current story progress, create a table with the debug log and the specific task section in the debug log - do not repeat all the details in the story]]

### Completion Notes List

[[LLM: (SM Agent) When Drafting Story, leave next prompt in place for dev agent to remove and update - remove this line to the SM]]
[[LLM: (Dev Agent) Anything the SM needs to know that deviated from the story that might impact drafting the next story.]]

### Change Log

[[LLM: (SM Agent) When Drafting Story, leave next prompt in place for dev agent to remove and update- remove this line to the SM]]
[[LLM: (Dev Agent) Track document versions and changes during development that deviate from story dev start]]

| Date | Version | Description | Author |
| :--- | :------ | :---------- | :----- |