# Story 5.27: UI Coordinator Architecture (Foundation for Future Immersive UI)

## Status: Draft

## Story

As a **developer**, I want **UI Coordinator architecture with debug overlay integration** so that I can **establish the foundation for future immersive UI while maintaining comprehensive debug capabilities**.

## Acceptance Criteria (ACs)

- [ ] UI Coordinator architecture implemented (without actual immersive rendering)
- [ ] Debug overlay system for Yew-based development tools
- [ ] Debug overlay conditionally compiled for development builds only
- [ ] Event routing infrastructure between future immersive UI and debug overlay
- [ ] State synchronization framework for UI and debug information
- [ ] Debug overlay can be toggled on/off during development
- [ ] Zero performance impact when debug overlay disabled
- [ ] Placeholder/stub immersive renderer for coordination testing

## Tasks / Subtasks

- [ ] Task 1: Implement UICoordinator trait and basic coordination architecture (AC: 1, 8)
  - [ ] Create `UICoordinator` trait with core interface methods for immersive UI coordination
  - [ ] Implement `PresentationCoordinator` struct as main coordinator implementation
  - [ ] Create `ImmersiveRenderer` trait interface for future graphics integration
  - [ ] Implement `StubImmersiveRenderer` for coordination testing without actual rendering
  - [ ] Add coordinator initialization and canvas integration support
  - [ ] Integrate coordinator with Application Core module registration system

- [ ] Task 2: Implement debug overlay system with conditional compilation (AC: 2, 3, 6)
  - [ ] Create `DebugOverlay` struct with Yew app integration for development tools
  - [ ] Implement debug overlay toggle functionality with visibility state management
  - [ ] Add conditional compilation using `#[cfg(debug_assertions)]` for all debug features
  - [ ] Create debug component registration system for managing multiple debug panels
  - [ ] Implement debug overlay layout management and positioning system
  - [ ] Ensure debug overlay completely excluded from production builds

- [ ] Task 3: Create event routing infrastructure for UI coordination (AC: 4, 5)
  - [ ] Design `UIEvent` enum for user interactions and UI state changes
  - [ ] Implement event routing between immersive UI and debug overlay systems
  - [ ] Create state synchronization framework for UI and debug information coordination
  - [ ] Add event handling infrastructure in UICoordinator for routing UI events
  - [ ] Implement event bus integration for inter-module communication
  - [ ] Add UI state management with bidirectional data flow support

- [ ] Task 4: Ensure zero performance impact for disabled debug features (AC: 7)
  - [ ] Implement performance monitoring for coordination layer overhead measurement
  - [ ] Add conditional compilation optimization to remove debug code paths in production
  - [ ] Create performance benchmarks to validate <1ms coordination overhead requirement
  - [ ] Implement lazy initialization for debug features to avoid startup overhead
  - [ ] Add runtime performance validation to ensure no impact when debug disabled
  - [ ] Create build validation tests to confirm debug code exclusion from production builds

- [ ] Task 5: Integration with Developer UI module from Story 5.26 (AC: 2, 6)
  - [ ] Integrate debug overlay with existing Developer UI module components
  - [ ] Connect debug overlay to developer_ui::DeveloperUI from previous story
  - [ ] Ensure seamless integration with existing debug component registration system
  - [ ] Add debug overlay coordination with existing error display and metrics components
  - [ ] Test integration with all migrated debug components from Story 5.26
  - [ ] Validate debug overlay functionality with existing developer UI workflows

- [ ] Task 6: Integration testing and architecture validation (AC: 1, 4, 5, 7, 8)
  - [ ] Create comprehensive integration tests for UI coordinator functionality
  - [ ] Test event routing infrastructure between future immersive UI and debug overlay
  - [ ] Validate state synchronization framework with real-time data flow
  - [ ] Test stub immersive renderer integration for coordination architecture validation
  - [ ] Verify zero performance impact through benchmarking with debug disabled
  - [ ] Create architecture validation tests ensuring readiness for Graphics Foundations integration

## Dev Technical Guidance

### Previous Story Context
[Source: docs/stories/5.26.story.md - Developer UI Module Creation Complete]

**Key Context from Story 5.26:**
- Developer UI module successfully created with complete conditional compilation using `#[cfg(debug_assertions)]`
- All 11 debug components migrated from legacy structure to `src/modules/developer_ui/` with preserved functionality
- Debug component registration system (`DebugComponentRegistry`) implemented and operational
- Overlay manager (`OverlayManager`) created for debug UI coordination and layout management
- Zero production impact achieved through complete module exclusion from production builds
- Solid foundation established for debug overlay integration with UI coordination architecture

### Source Tree Context
[Source: docs/architecture/source-tree.md#modular-architecture]

**Implementation Target Files:**
- Module root: `src/modules/presentation_layer/mod.rs`
- UI Coordinator: `src/modules/presentation_layer/ui_coordinator.rs`
- Presentation Coordinator: `src/modules/presentation_layer/presentation_coordinator.rs`
- Debug overlay integration: `src/modules/presentation_layer/debug_overlay.rs`
- Event handling: `src/modules/presentation_layer/event_handler.rs`
- Theme management: `src/modules/presentation_layer/theme_manager.rs`

**Integration Points:**
- Developer UI module: `src/modules/developer_ui/` (from Story 5.26)
- Application Core: `src/modules/application_core/` for module registration
- Future Graphics Foundations: `src/modules/graphics_foundations/` (Story 5.29)

### Architecture Context
[Source: docs/architecture/modular-restructure-architecture.md#presentation-layer]

**Presentation Layer Module Requirements:**
- **UI Coordination**: Manage coordination between HTML components and future immersive rendering
- **Debug Integration**: Seamless integration with conditionally compiled Developer UI module
- **Event System**: Route events between different UI systems (HTML, immersive, debug)
- **State Management**: Synchronize state across UI subsystems with minimal overhead
- **Performance**: Coordination layer overhead must be <1ms when debug disabled

**Module Architecture Pattern:**
```rust
pub trait UICoordinator: Send + Sync {
    fn render_immersive_ui(&mut self, state: &UIState) -> Result<(), RenderError>;
    #[cfg(debug_assertions)]
    fn render_debug_overlay(&mut self, debug_state: &DebugState) -> Result<(), RenderError>;
    #[cfg(debug_assertions)]
    fn toggle_debug_overlay(&mut self, visible: bool);
    fn handle_ui_event(&mut self, event: UIEvent) -> Result<(), UIError>;
    fn update_state(&mut self, state: UIState);
}

pub struct PresentationCoordinator {
    // STUB RENDERER - Will be replaced with wgpu renderer in Graphics Epic
    immersive_renderer: Box<dyn ImmersiveRenderer>,
    #[cfg(debug_assertions)]
    developer_ui: Option<crate::modules::developer_ui::DeveloperUI>,
    event_bus: Arc<dyn EventBus>,
}
```

### Technology Stack Context
[Source: docs/architecture/tech-stack.md#yew-framework]

**Yew Framework Integration:**
- **Version**: Yew 0.21 for component-based debug UI coordination
- **Component Pattern**: Function components with hooks for state management in debug overlay
- **Conditional Compilation**: All Yew debug components must use `#[cfg(debug_assertions)]`
- **Performance**: Debug overlay rendering must stay under 5ms to avoid interfering with future main UI

**Debug Integration Pattern:**
```rust
#[cfg(debug_assertions)]
pub struct DebugOverlay {
    yew_app: App<DebugApp>,
    overlay_visible: bool,
    debug_components: Vec<Box<dyn DebugComponent>>,
}

#[cfg(debug_assertions)]
impl DebugOverlay {
    pub fn toggle_visibility(&mut self, visible: bool) {
        self.overlay_visible = visible;
        // Update debug UI visibility
    }
    
    pub fn update_debug_state(&mut self, state: &DebugState) {
        // Synchronize debug information
    }
}
```

### Conditional Compilation Strategy
[Source: docs/architecture/modular-restructure-architecture.md#development-tools]

**Debug Build Feature Flags:**
- Use `#[cfg(debug_assertions)]` for automatic debug/release distinction throughout coordination layer
- Implement feature-based compilation for granular debug tool control
- Ensure complete debug system exclusion from production builds
- Support development-time feature toggling for debug overlay visibility

**Production Build Requirements:**
- **Zero Build Size Impact**: Debug overlay and coordination completely excluded from production WASM
- **Zero Runtime Impact**: No debug code paths or coordination overhead in production builds
- **Clean Separation**: No production code dependencies on debug overlay APIs

### Event System Integration
[Source: docs/architecture/modular-restructure-architecture.md#application-core]

**Event Bus Integration:**
```rust
// Event types for UI coordination
#[derive(Debug, Clone)]
pub enum UIEvent {
    UserInteraction(UserInteraction),
    StateUpdate(UIState),
    DebugToggle(bool),
    NoOp,
}

// Integration with Application Core event system
impl PresentationCoordinator {
    pub fn handle_ui_event(&mut self, event: UIEvent) -> Result<(), UIError> {
        match event {
            UIEvent::UserInteraction(interaction) => {
                self.immersive_renderer.handle_interaction(interaction)?;
            }
            UIEvent::StateUpdate(state) => {
                self.update_state(state);
            }
            #[cfg(debug_assertions)]
            UIEvent::DebugToggle(visible) => {
                if let Some(ref mut debug_ui) = self.developer_ui {
                    debug_ui.toggle_overlay(visible);
                }
            }
            UIEvent::NoOp => {}
        }
        Ok(())
    }
}
```

### Module Registration Integration
[Source: docs/architecture/modular-restructure-architecture.md#application-core]

**Application Core Integration:**
```rust
// Presentation Layer module registration
impl Module for PresentationLayerModule {
    fn initialize(&mut self) -> Result<(), ModuleError> {
        // Initialize UI coordinator
        self.ui_coordinator.initialize()?;
        
        // Register debug overlay (debug builds only)
        #[cfg(debug_assertions)]
        self.register_debug_overlay()?;
        
        // Connect to application event bus
        self.setup_event_integration()?;
        
        Ok(())
    }
}
```

### Performance Requirements
[Source: docs/architecture/coding-standards.md#performance-standards]

**Coordination Performance Standards:**
- **UI Coordination Overhead**: Target <1ms, maximum 5ms when debug enabled
- **Debug Overlay Rendering**: Target <5ms, maximum 10ms to avoid main UI interference  
- **Event Routing Latency**: Target <1ms for UI responsiveness
- **State Synchronization**: Target <2ms for real-time debug information updates

**Memory Management:**
- Efficient state management using Rust ownership patterns
- Minimal heap allocations in coordination hot paths
- Debug overlay memory isolated from main application memory usage

## Testing

Unit Tests: `#[cfg(test)]` modules next to implementation, coverage requirement: 90%

Integration Tests: `src/modules/presentation_layer/integration_tests.rs`

Performance Tests: Validate coordination overhead <1ms requirement

Manual Test Steps:

1. Verify UI coordinator initializes successfully and integrates with Application Core
2. Test debug overlay toggle functionality in debug builds (should show/hide debug components)
3. Confirm production builds completely exclude debug overlay features
4. Test event routing between stub immersive renderer and debug overlay
5. Validate state synchronization between UI systems with real-time updates
6. Verify performance requirements through benchmark testing
7. Test integration with Developer UI module components from Story 5.26

## Dev Agent Record

### Agent Model Used: 

### Debug Log References

[[LLM: (Dev Agent) If the debug is logged to during the current story progress, create a table with the debug log and the specific task section in the debug log - do not repeat all the details in the story]]

### Completion Notes List

[[LLM: (Dev Agent) Anything the SM needs to know that deviated from the story that might impact drafting the next story.]]

### Change Log

[[LLM: (Dev Agent) Track document versions and changes during development that deviate from story dev start]]

| Date | Version | Description | Author |
| :--- | :------ | :---------- | :----- |