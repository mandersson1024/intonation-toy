# Story 2.1: Implement microphone permission request flow with user-friendly UI

## Status: Approved

## Story

- As a **music educator or student**
- I want **to grant microphone access with a clear, child-friendly permission flow**
- so that **I can use real audio input for pitch detection without confusion or technical barriers**

## Acceptance Criteria (ACs)

1. **AC1**: Microphone permission request displays clear, child-friendly messaging explaining why access is needed
2. **AC2**: Permission denial is handled gracefully with instructional guidance for enabling access
3. **AC3**: Web Audio API context initializes properly after permission grant with error handling
4. **AC4**: Microphone input stream connects successfully to audio processing pipeline established in EP-001
5. **AC5**: Cross-browser compatibility for getUserMedia API across Chrome, Firefox, Safari, Edge
6. **AC6**: Error states provide actionable feedback with retry mechanisms for common issues

## Tasks / Subtasks

- [ ] Task 1: Create microphone permission request UI with child-friendly messaging (AC: 1, 2)
  - [ ] Design and implement permission request modal with clear visual instructions
  - [ ] Add child-friendly explanatory text about microphone usage for music learning
  - [ ] Create visual indicators (icons, animations) to make the process engaging
  - [ ] Implement permission denial handling with step-by-step guidance for re-enabling
  
- [ ] Task 2: Implement getUserMedia API integration with error handling (AC: 3, 5, 6)
  - [ ] Add navigator.mediaDevices.getUserMedia() implementation with proper constraints
  - [ ] Implement cross-browser compatibility checks and fallbacks
  - [ ] Add comprehensive error handling for various permission denial scenarios
  - [ ] Create retry mechanisms for transient failures
  
- [ ] Task 3: Initialize Web Audio API context and connect to existing WASM pipeline (AC: 4)
  - [ ] Create AudioContext initialization after permission grant
  - [ ] Connect microphone input stream to AudioWorklet established in Story 1.2
  - [ ] Implement proper cleanup and resource management
  - [ ] Add connection validation and error reporting
  
- [ ] Task 4: Enhance testing infrastructure for browser permission flows (AC: 5, 6)
  - [ ] Add automated tests for permission flow user interface
  - [ ] Create mock getUserMedia tests for various scenarios (grant, deny, error)
  - [ ] Implement cross-browser permission testing pipeline
  - [ ] Add manual testing documentation for real browser permission flows

## Dev Notes

### Previous Story Insights from Story 1.3

**Foundation Assets Available:**
- ✅ **Professional Test Infrastructure**: Enhanced browser test suite at http://localhost:8080/web/
- ✅ **WASM Audio Engine**: AudioEngine class ready for real audio input integration
- ✅ **Performance Validation**: 0.08-0.09ms processing latency provides significant headroom
- ✅ **Cross-browser Compatibility**: Chrome, Firefox, Safari, Edge validation framework established
- ✅ **Development Workflow**: Ruby server with automated build process via `./dev.sh`

**Key Technical Achievements to Build Upon:**
- WASM processing pipeline established and performance-validated
- TestFramework class architecture provides testing foundation for permission flows
- Cross-browser compatibility matrix established (can extend for getUserMedia testing)
- Professional UI patterns and error handling established in test suite

### Technical Guidance from Architecture Documents

**Web Audio API Requirements**: [Source: architecture/tech-stack.md#Core Dependencies]
- **getUserMedia API**: Required browser feature for microphone access
- **Web Audio API**: AudioContext initialization after permission grant
- **AudioWorklet Integration**: Connect to existing processor from Story 1.2
- **Cross-browser Support**: Chrome, Firefox, Safari, Edge compatibility required

**Frontend UI Patterns**: [Source: architecture/frontend-architecture.md#UI Component Pattern]
- **Component-like Functions**: Use updateStatus(), updateMetric() patterns established
- **State Management**: Centralized state in main controller class
- **Error Boundaries**: Graceful error handling and recovery patterns
- **Progressive Enhancement**: Core functionality with layered enhancements
- **Accessibility**: WCAG 2.1 AA compliance, keyboard navigation, screen reader support

**File Locations**: [Source: architecture/unified-project-structure.md#Web Frontend]
- **Main Controller**: `web/app.js` - application state management and permission flow
- **HTML Structure**: `web/index.html` - add permission request UI components
- **Styling**: `web/style.css` - child-friendly permission interface styling
- **AudioWorklet**: `web/audio-worklet.js` - integrate microphone stream with existing processor

**Performance Constraints**: [Source: architecture/tech-stack.md#Performance Constraints]
- **Audio Latency**: <50ms total (already achieved in EP-001: 0.08ms processing)
- **Buffer Size**: 1024-2048 samples for web stability
- **Processing Budget**: <70% of AudioWorklet quantum
- **Memory Management**: Minimal allocations, cleanup on permission denial

**Browser Compatibility**: [Source: architecture/frontend-architecture.md#Browser Support Matrix]
- **Target Browsers**: Chrome 90+, Firefox 88+, Safari 14+, Edge 90+
- **Feature Detection**: Extend existing checks for getUserMedia support
- **Polyfills**: Graceful degradation for unsupported browsers
- **Error Handling**: Browser-specific getUserMedia error handling

### Development Infrastructure

**Current Setup** (Build upon existing):
- **Development Server**: Ruby server at http://localhost:8080 via `./dev.sh`
- **Test Suite Location**: `web/index.html` with TestFramework class
- **WASM Build Process**: `wasm-pack build --target web` automated in dev script
- **Cross-browser Testing**: Framework established, extend for permission testing

**New Components to Add**:
- Permission request modal in existing HTML structure
- getUserMedia integration in `app.js` controller
- Permission state management in TestFramework
- Child-friendly UI styling in CSS

### Testing

Dev Note: Story Requires the following tests:

- [x] **Unit Tests**: Jest tests for permission request logic (nextToFile: true), coverage requirement: 80%
- [x] **Integration Tests**: Browser-based getUserMedia testing with mock implementations, location: `tests/browser-automation/permission-flow.spec.js`
- [x] **E2E Tests**: Cross-browser permission flow validation, location: `tests/browser-automation/cross-browser-permissions.spec.js`

**Manual Test Steps**: 
- Start development server with `./dev.sh`
- Navigate to http://localhost:8080/web/ in target browsers
- Test permission request flow: grant, deny, and re-enable scenarios
- Validate child-friendly messaging and visual feedback
- Confirm audio input connection to existing WASM processing pipeline
- Test cross-browser compatibility (Chrome, Firefox, Safari, Edge)

## Dev Agent Record

### Agent Model Used: {{Agent Model Name/Version}}

### Debug Log References

[[LLM: (SM Agent) When Drafting Story, leave next prompt in place for dev agent to remove and update]]
[[LLM: (Dev Agent) If the debug is logged to during the current story progress, create a table with the debug log and the specific task section in the debug log - do not repeat all the details in the story]]

### Completion Notes List

[[LLM: (SM Agent) When Drafting Story, leave next prompt in place for dev agent to remove and update - remove this line to the SM]]
[[LLM: (Dev Agent) Anything the SM needs to know that deviated from the story that might impact drafting the next story.]]

### Change Log

[[LLM: (SM Agent) When Drafting Story, leave next prompt in place for dev agent to remove and update- remove this line to the SM]]
[[LLM: (Dev Agent) Track document versions and changes during development that deviate from story dev start]]

| Date | Version | Description | Author |
| :--- | :------ | :---------- | :----- |
| 2025-06-21 | 1.0 | Story created - ready for implementation | Sarah (PO Agent - BMAD) |
| 2025-06-21 | 1.1 | Story approved for development | Sarah (PO Agent - BMAD) | 