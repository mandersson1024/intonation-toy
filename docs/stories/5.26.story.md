# Story 5.26: Developer UI Module Creation

## Status: Draft

## Story

As a **developer**, I want **existing Yew debug components organized in a dedicated Developer UI module** so that I can **maintain comprehensive debugging tools while keeping them completely separate from immersive user experience code**.

## Acceptance Criteria (ACs)

- [ ] New `developer_ui` module created with clear separation from presentation layer
- [ ] All existing Yew debug components moved to `src/modules/developer_ui/`
- [ ] Developer UI module conditionally compiled for debug builds only
- [ ] Component registration system for debug overlay management
- [ ] All existing debug functionality preserved
- [ ] Zero impact on production builds (module completely excluded)
- [ ] Clear architectural boundaries between debug tools and user experience

## Tasks / Subtasks

- [ ] Task 1: Create Developer UI module structure and conditional compilation (AC: 1, 3, 6)
  - [ ] Create `src/modules/developer_ui/mod.rs` with `#[cfg(debug_assertions)]` conditional compilation
  - [ ] Set up module registration with Application Core ModuleRegistry for debug builds only
  - [ ] Implement conditional compilation flags to exclude entire module from production builds
  - [ ] Create module initialization and lifecycle management integrated with Application Core
  - [ ] Add module documentation and architectural boundaries specification
  - [ ] Verify zero production build impact through build size comparison testing

- [ ] Task 2: Migrate existing debug components to Developer UI module (AC: 2, 5)
  - [ ] Move `legacy/active/components/audio_control_panel.rs` to `src/modules/developer_ui/components/audio_controls/audio_control_panel.rs`
  - [ ] Move `legacy/active/components/debug_interface.rs` to `src/modules/developer_ui/components/debug_interface/debug_interface.rs`
  - [ ] Move `legacy/active/components/debug_panel.rs` to `src/modules/developer_ui/components/debug_interface/debug_panel.rs`
  - [ ] Move `legacy/active/components/error_display.rs` to `src/modules/developer_ui/components/error_display/error_display.rs`
  - [ ] Move `legacy/active/components/error_toast.rs` to `src/modules/developer_ui/components/error_display/error_toast.rs`
  - [ ] Move `legacy/active/components/metrics_display.rs` to `src/modules/developer_ui/components/metrics_display/metrics_display.rs`
  - [ ] Move `legacy/active/components/performance_monitor.rs` to `src/modules/developer_ui/components/metrics_display/performance_monitor.rs`
  - [ ] Move `legacy/active/components/microphone_panel.rs` to `src/modules/developer_ui/components/audio_controls/microphone_panel.rs`
  - [ ] Move `legacy/active/components/microphone_permission.rs` to `src/modules/developer_ui/components/microphone_permission/microphone_permission.rs`
  - [ ] Move `legacy/active/components/test_signal_generator.rs` to `src/modules/developer_ui/components/audio_controls/test_signal_generator.rs`
  - [ ] Move `legacy/active/components/fallback_ui.rs` to `src/modules/developer_ui/components/microphone_permission/fallback_ui.rs`
  - [ ] Update all import statements and module references to reflect new locations
  - [ ] Preserve all existing component functionality and interfaces during migration

- [ ] Task 3: Migrate debug hooks to Developer UI module (AC: 2, 5)
  - [ ] Move `legacy/active/hooks/use_error_handler.rs` to `src/modules/developer_ui/hooks/use_error_handler.rs`
  - [ ] Move `legacy/active/hooks/use_microphone_permission.rs` to `src/modules/developer_ui/hooks/use_microphone_permission.rs`
  - [ ] Update hook exports and imports to maintain existing functionality
  - [ ] Ensure hooks remain conditionally compiled for debug builds only
  - [ ] Verify all hook dependencies work correctly in new module structure

- [ ] Task 4: Implement debug component registration system (AC: 4, 7)
  - [ ] Create `DebugComponentRegistry` trait for component management and overlay coordination
  - [ ] Implement component registration system supporting dynamic debug component discovery
  - [ ] Create debug overlay manager for coordinating multiple debug components
  - [ ] Implement debug component lifecycle management (initialization, updates, cleanup)
  - [ ] Add debug component state synchronization and event handling
  - [ ] Create clear architectural boundaries documentation between debug tools and main application

- [ ] Task 5: Create Developer UI main application structure (AC: 7)
  - [ ] Implement `debug_app.rs` as main debug application coordinator
  - [ ] Create `overlay_manager.rs` for debug overlay coordination and layout management
  - [ ] Implement debug UI event system integration with main application
  - [ ] Add debug UI state management and persistence for development sessions
  - [ ] Create debug UI theme and styling system separate from main application themes
  - [ ] Implement debug UI performance monitoring to ensure no impact on main application

- [ ] Task 6: Integration testing and validation (AC: 5, 6, 7)
  - [ ] Create comprehensive integration tests validating debug functionality preservation
  - [ ] Implement production build testing to verify complete exclusion of Developer UI module
  - [ ] Test debug component registration and overlay management system
  - [ ] Validate conditional compilation works correctly across all build profiles
  - [ ] Perform build size analysis to confirm zero production impact
  - [ ] Test architectural boundaries and ensure clean separation from presentation layer

## Dev Technical Guidance

### Previous Story Context
[Source: docs/stories/4.25.story.md - Data Flow Coordination System Complete]

**Key Context from Story 4.25:**
- Comprehensive data flow coordination system implemented with >1000 ops/sec throughput
- Real-time audio pipeline management with <2ms latency enforcement
- Robust backpressure handling and error recovery mechanisms operational
- Integration testing completed across all existing modules (Audio Foundations, Application Core, Platform Abstraction)
- Data flow visualization support ready for Development Tools module integration
- Solid foundation of modular architecture with clear module boundaries established

### Source Tree Context
[Source: docs/architecture/source-tree.md#modular-architecture]

**Implementation Target Files:**
- Module root: `src/modules/developer_ui/mod.rs`
- Debug app: `src/modules/developer_ui/debug_app.rs`
- Overlay manager: `src/modules/developer_ui/overlay_manager.rs`
- Component directories: `src/modules/developer_ui/components/{audio_controls,debug_interface,error_display,metrics_display,microphone_permission}/`
- Hook integration: `src/modules/developer_ui/hooks/`

**Legacy Migration Sources:**
- From: `src/legacy/active/components/` 
- From: `src/legacy/active/hooks/`
- To: `src/modules/developer_ui/components/` and `src/modules/developer_ui/hooks/`

### Architecture Context
[Source: docs/architecture/modular-restructure-architecture.md#module-architecture]

**Developer UI Module Architecture Requirements:**
- **Module Isolation**: Complete separation between developer tools and user experience
- **Conditional Compilation**: Developer UI entirely excluded from production builds using `#[cfg(debug_assertions)]`
- **Zero Production Impact**: No build size or runtime performance impact in production
- **Clear Boundaries**: Architectural separation preventing any cross-contamination with immersive UI

**Module Structure Pattern:**
```rust
// Developer UI module with conditional compilation
#[cfg(debug_assertions)]
pub mod developer_ui;

#[cfg(debug_assertions)]
pub struct DeveloperUIModule {
    debug_app: DebugApp,
    overlay_manager: OverlayManager,
    component_registry: DebugComponentRegistry,
    event_bus: Arc<dyn EventBus>,
}

#[cfg(debug_assertions)]
impl Module for DeveloperUIModule {
    fn initialize(&mut self) -> Result<(), ModuleError> {
        // Register debug components
        self.register_all_debug_components()?;
        
        // Initialize debug overlay system
        self.overlay_manager.initialize()?;
        
        // Connect to main application event system
        self.setup_debug_event_integration()?;
        
        Ok(())
    }
}
```

### Technology Stack Context
[Source: docs/architecture/tech-stack.md#yew-framework]

**Yew Framework Integration:**
- **Version**: Yew 0.21 for component-based debug UI
- **Component Pattern**: Function components with hooks for state management
- **Conditional Compilation**: All Yew debug components must be conditionally compiled
- **Build Integration**: Trunk build system must exclude debug components from production builds

**Component Architecture Pattern:**
```rust
#[cfg(debug_assertions)]
#[function_component(DebugComponent)]
pub fn debug_component(props: &DebugProps) -> Html {
    let debug_state = use_state(|| DebugState::new());
    
    // Debug-specific logic
    use_effect_with_deps(move |_| {
        // Debug functionality
        || ()
    }, ());
    
    html! {
        <div class="debug-component">
            // Debug UI elements
        </div>
    }
}
```

### Conditional Compilation Strategy
[Source: docs/architecture/modular-restructure-architecture.md#conditional-compilation]

**Debug Build Feature Flags:**
- Use `#[cfg(debug_assertions)]` for automatic debug/release distinction
- Implement feature-based compilation for granular debug tool control
- Ensure complete module exclusion from production builds
- Support development-time feature toggling for debug components

**Production Build Requirements:**
- **Zero Build Size Impact**: Debug module completely excluded from production WASM
- **Zero Runtime Impact**: No debug code paths or overhead in production
- **Clean Separation**: No production code dependencies on debug module APIs

### Component Migration Requirements
[Source: docs/architecture/legacy-migration-tracking.md]

**Migration Source Mapping:**
- `legacy/active/components/audio_control_panel.rs` → `developer_ui/components/audio_controls/audio_control_panel.rs`
- `legacy/active/components/debug_interface.rs` → `developer_ui/components/debug_interface/debug_interface.rs`
- `legacy/active/components/debug_panel.rs` → `developer_ui/components/debug_interface/debug_panel.rs`
- `legacy/active/components/error_display.rs` → `developer_ui/components/error_display/error_display.rs`
- `legacy/active/components/error_toast.rs` → `developer_ui/components/error_display/error_toast.rs`
- `legacy/active/components/metrics_display.rs` → `developer_ui/components/metrics_display/metrics_display.rs`
- `legacy/active/components/performance_monitor.rs` → `developer_ui/components/metrics_display/performance_monitor.rs`
- `legacy/active/components/microphone_panel.rs` → `developer_ui/components/audio_controls/microphone_panel.rs`
- `legacy/active/components/microphone_permission.rs` → `developer_ui/components/microphone_permission/microphone_permission.rs`
- `legacy/active/components/test_signal_generator.rs` → `developer_ui/components/audio_controls/test_signal_generator.rs`
- `legacy/active/components/fallback_ui.rs` → `developer_ui/components/microphone_permission/fallback_ui.rs`

**Hook Migration:**
- `legacy/active/hooks/use_error_handler.rs` → `developer_ui/hooks/use_error_handler.rs`
- `legacy/active/hooks/use_microphone_permission.rs` → `developer_ui/hooks/use_microphone_permission.rs`

### Module Registration and Integration
[Source: docs/architecture/modular-restructure-architecture.md#application-core]

**Application Core Integration:**
```rust
#[cfg(debug_assertions)]
impl ModuleRegistry {
    pub fn register_developer_ui(&mut self) -> Result<(), ModuleError> {
        let developer_ui = DeveloperUIModule::new()?;
        self.register_module("developer_ui", Box::new(developer_ui))
    }
}

// Main application initialization
#[cfg(debug_assertions)]
fn initialize_debug_modules(registry: &mut ModuleRegistry) -> Result<(), ModuleError> {
    registry.register_developer_ui()?;
    Ok(())
}
```

### Testing Requirements
[Source: docs/architecture/testing-strategy.md#conditional-compilation-testing]

**Testing Strategy:**
- **Unit Tests**: Test all debug components with `#[cfg(debug_assertions)]`
- **Integration Tests**: Validate debug module registration and lifecycle
- **Build Tests**: Verify production builds exclude debug module completely
- **Functionality Tests**: Ensure all existing debug functionality preserved

**Test Structure:**
```rust
#[cfg(test)]
#[cfg(debug_assertions)]
mod debug_tests {
    use super::*;
    
    #[test]
    fn test_debug_component_functionality() {
        // Test debug component behavior
    }
    
    #[test]
    fn test_conditional_compilation() {
        // Verify debug components only available in debug builds
    }
}
```

### Performance and Build Impact
[Source: docs/architecture/coding-standards.md#performance-standards]

**Build Performance Requirements:**
- **Debug Build**: Fast compilation with full debug tooling available
- **Production Build**: Optimized compilation with zero debug overhead
- **Build Size**: Production WASM must show no size increase from debug module
- **Runtime Performance**: Zero performance impact on main application from debug module presence

## Testing

Unit Tests: `#[cfg(test)]` modules next to implementation, coverage requirement: 90%

Integration Tests: `src/modules/developer_ui/integration_tests.rs`

Build Impact Tests: Validate production build size and debug module exclusion

Component Migration Tests: Verify all existing debug functionality preserved during migration

Manual Test Steps:

1. Verify debug components are available in debug builds and functional
2. Confirm production builds completely exclude developer_ui module
3. Test debug component registration and overlay management
4. Validate architectural boundaries between debug tools and main application
5. Confirm zero performance impact on main application
6. Test conditional compilation across different build profiles

## Dev Agent Record

### Agent Model Used: 

### Debug Log References

### Completion Notes List

### Change Log

| Date | Version | Description | Author |
| :--- | :------ | :---------- | :----- |